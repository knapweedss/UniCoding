{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "4ddfb731",
   "metadata": {},
   "source": [
    "# Множители и делители"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0c1f76d5",
   "metadata": {},
   "source": [
    "### Задача 1: Поиск наибольшего общего делителя"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a337a22a",
   "metadata": {},
   "source": [
    "**НОД**, или **наибольший общий делитель** двух целых чисел — наибольшее число, на которое эти два числа делятся. Например, для 91 и 28 НОД равен 7, а для 36 и 47 НОД равен 1."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "eee36c68",
   "metadata": {},
   "source": [
    "Напишем рекурсивную функцию для поиска НОД двух чисел, a и b. Будем по умолчанию считать, что a > b. В каждой итерации мы находим остаток от деления a % b и запускаем эту же функцию для b и получившегося остатка. Если b достигло 0, значит, рекурсия достигла конца, и мы возвращаем a. Выведем переменные каждой итерации, чтобы посмотреть, как это работает."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 148,
   "id": "1d092bfc",
   "metadata": {},
   "outputs": [],
   "source": [
    "def gcd(a, b):\n",
    "    print(f\">> a = {a}, b = {b}\")\n",
    "    if b == 0:\n",
    "        return a\n",
    "    return gcd(b, a%b)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "075e2247",
   "metadata": {},
   "source": [
    "Функция *map* позволяет присвоить набору переменных значения из списка. Так можно с помощью *input* вводить значения через пробел, потом делить их по пробелам функцией *split*, а затем быстро присваивать значения из полученного списка переменым a и b."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 149,
   "id": "3c0b2c02",
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Введите a и b: 85 34\n",
      ">> a = 85, b = 34\n",
      ">> a = 34, b = 17\n",
      ">> a = 17, b = 0\n",
      "17\n"
     ]
    }
   ],
   "source": [
    "a, b = map(int, input(\"Введите a и b: \").split())\n",
    "print(gcd(a, b))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b537ff1d",
   "metadata": {},
   "source": [
    "(Это очень удобно, но дальше в конспекте я буду писать конкретные значения, чтобы его было легче читать без запуска тетрадки.)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 150,
   "id": "c6c4446e",
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      ">> a = 85, b = 34\n",
      ">> a = 34, b = 17\n",
      ">> a = 17, b = 0\n",
      "17\n"
     ]
    }
   ],
   "source": [
    "print(gcd(85, 34))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1635d433",
   "metadata": {},
   "source": [
    "Что будет, если a < b? В таком случае на первой итерации a % b будет равняться a. Например, 21 % 87 = 21. А мы подаём в следующую итерацию b и a%b, то есть b и a. Фактически, за счёт этой дополнительной итерации a и b просто поменяются местами."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 151,
   "id": "71ec9b1d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "21 3\n",
      "87 21\n"
     ]
    }
   ],
   "source": [
    "a, b = 87, 21\n",
    "print(b, a%b)\n",
    "a, b = 21, 87\n",
    "print(b, a%b)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "395a9724",
   "metadata": {},
   "source": [
    "Убедимся, что это так. Сравните вывод с a=34, b=85 и вывод с a=85, b=34, который был выше. Всё то же самое, только в начале появилась дополнительная итерация, которая меняет a и b местами. Засчёт этого можно не проверять, что a > b."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 152,
   "id": "0e984fe9",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      ">> a = 34, b = 85\n",
      ">> a = 85, b = 34\n",
      ">> a = 34, b = 17\n",
      ">> a = 17, b = 0\n",
      "17\n"
     ]
    }
   ],
   "source": [
    "print(gcd(34, 85))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ded60f21",
   "metadata": {},
   "source": [
    "Попробуем реализовать ту же логику не через рекурсию, а через цикл:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 155,
   "id": "a86bba50",
   "metadata": {},
   "outputs": [],
   "source": [
    "def gcd_2(a, b):\n",
    "    while b:  # имеется в виду: пока b > 0\n",
    "        print(f\">> a = {a}, b = {b}\")\n",
    "        a, b = b, a%b\n",
    "    return a"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 156,
   "id": "8847d939",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      ">> a = 85, b = 34\n",
      ">> a = 34, b = 17\n",
      "17\n"
     ]
    }
   ],
   "source": [
    "print(gcd_2(85, 34))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1f01335f",
   "metadata": {},
   "source": [
    "Можно увидеть, что итераций получается меньше."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9981ffb1",
   "metadata": {},
   "source": [
    "### Задача 2: Проверка на «простоту»"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "203e29f3",
   "metadata": {},
   "source": [
    "Целое число называют **простым**, если оно делится только на 1 и на само себя. Напишем функцию, которая будет определять, является ли число n простым. Для этого нам нужно найти какой-нибудь делитель n в диапазоне (1, n). Если мы такой делитель находим, то число не простое."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 173,
   "id": "16cf81c4",
   "metadata": {},
   "outputs": [],
   "source": [
    "def simple(n):\n",
    "    i = 2\n",
    "    while i < n:\n",
    "        if n % i == 0:\n",
    "            return False  # нашли делитель: число не является простым\n",
    "        i += 1\n",
    "    return True  # делители не найдены: число простое"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8b52b6eb",
   "metadata": {},
   "source": [
    "Функция перебирает итератором i числа, начиная с двойки. Нам нужно перебрать все числа от двойки до n и найти среди них делители. Если данное число n делится на i без остатка, то оно не простое, мы прерываем цикл и выдаём False. Если ни в одной итерации такого не произошло, а i уже достигло n, цикл прекращается (это описано через *while*). Если функция дошла до этого момента, значит, делителей мы не нашли. Поэтому мы сообщаем пользователю, что число простое, и выдаём True."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4f5f5a75",
   "metadata": {},
   "source": [
    "Такую функцию можно немного оптимизировать. По большому счёту, мы ищем наименьший делитель n, который больше 1 (вообще мы ищем любой делитель, но числа перебираются от 1 до n, поэтому мы можем найти либо наименьшей делитель, либо не найти никакого). Но наименьший делитель не может быть больше, чем корень из n. Например: наименьший делитель числа 100 не может быть больше 10. Да, есть делители, например, 30, 50 и другие, но все они не простые числа, а значит, не наименьшие делители. То есть если мы достигли корня из n и ничего не нашли, перебор можно заканчивать. Более подробное и понятное доказательство можно почитать [здесь](http://mech.math.msu.su/~shvetz/54/inf/perl-problems/chPrimes_sIdeas.xhtml)."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "efd2f081",
   "metadata": {},
   "source": [
    "Напишем *while* таким образом, чтобы i был меньше или равен корню из n. Или, проще, i в квадрате был меньше или равен n."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 172,
   "id": "270ae8ec",
   "metadata": {},
   "outputs": [],
   "source": [
    "def simple(n):\n",
    "    i = 2\n",
    "    while i**2 <= n:  # <-- заменили i на i**2\n",
    "        if n % i == 0:\n",
    "            return False\n",
    "        i += 1\n",
    "    return True"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 177,
   "id": "d7226599",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "True\n",
      "False\n"
     ]
    }
   ],
   "source": [
    "print(simple(131))  # простое число\n",
    "print(simple(133))  # не простое: 133 = 19*7"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6c50978a",
   "metadata": {},
   "source": [
    "Всё работает правильно."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d54f43da",
   "metadata": {},
   "source": [
    "### Задача 3: Разложение на множители"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ccbba6e0",
   "metadata": {},
   "source": [
    "Разложение на множители, или факторизация — это попросту поиск всех простых множителей числа. В результате такой операции должен получиться список простых чисел, которые можно перемножить, чтобы получить изначальное число. Например, для числа 38 264 594 простые множители выглядят так: 43 781 * 23 * 19 * 2 = 38 264 594."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "01aa2873",
   "metadata": {},
   "source": [
    "Функция для поиска множителей будет похожа на функцию проверки на простоту, которую мы уже написали выше. Будем перебирать числа, начиная с двойки и до корня из n (помним об оптимизации). Если мы наткнулись на делитель, делим на него до упора, пока результат остаётся целым. Все найденные простые делители будем складывать в список k."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 203,
   "id": "349fe18b",
   "metadata": {},
   "outputs": [],
   "source": [
    "def factorization(n):\n",
    "    k = []\n",
    "    i = 2\n",
    "    while i**2 <= n:\n",
    "        while n % i == 0:  # <-- делим на i до упора, пока получается без остатка\n",
    "            print(f\">> i = {i}, n = {n}\")\n",
    "            k.append(i)\n",
    "            n //= i\n",
    "        i += 1\n",
    "    return k"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e75ea3dc",
   "metadata": {},
   "source": [
    "С таким алгоритмом может получиться так, что последний множитель не добавлен в список. Например, попробуем разложить число 20. Делим на двойку до упора: 20 // 2 = 10, 10 // 2 = 5. Теперь n = 5. Мы могли бы продолжить перебор, но мешает условие оптимизации, которое мы сами поставили в *while*. Следующее число в переборе должно быть 3, но 3 в квадрате больше, чем 5, и перебор не продолжается. Таким образом, число 5 не добавляется в список k.\n",
    "\n",
    "Эту проблему можно решить по-разному. Простой способ: после окончания цикла добавить в список переменную n, оставшуюся после деления. Поставим условие: n не должно быть равно 1 (1 по понятным причинам не считается релевантным множителем)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 200,
   "id": "370b4943",
   "metadata": {},
   "outputs": [],
   "source": [
    "def factorization(n):\n",
    "    k = []\n",
    "    i = 2\n",
    "    while i**2 <= n:\n",
    "        while n % i == 0:\n",
    "            print(f\">> i = {i}, n = {n}\")\n",
    "            k.append(i)\n",
    "            n //= i\n",
    "        i += 1\n",
    "    if n != 1:  # <-- добавляем оставшийся множитель, если это не единица\n",
    "        print(f\">> n = {n}\")\n",
    "        k.append(n)\n",
    "    return k"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 201,
   "id": "8db2bd76",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      ">> i = 2, n = 20\n",
      ">> i = 2, n = 10\n",
      ">> n = 5\n",
      "[2, 2, 5]\n"
     ]
    }
   ],
   "source": [
    "print(factorization(20))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 202,
   "id": "34a8b779",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      ">> i = 2, n = 38264594\n",
      ">> i = 19, n = 19132297\n",
      ">> i = 23, n = 1006963\n",
      ">> n = 43781\n",
      "[2, 19, 23, 43781]\n"
     ]
    }
   ],
   "source": [
    "print(factorization(38264594))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1c8681bf",
   "metadata": {},
   "source": [
    "Всё работает!"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "983db515",
   "metadata": {},
   "source": [
    "### Задача 4: Решето Эратосфена"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ad753bdc",
   "metadata": {},
   "source": [
    "**Решето Эратосфена** — один из известных алгоритмов поиска простых чисел в определённом диапазоне.\n",
    "\n",
    "На каждой итерации алгоритма мы «отсеиваем» те числа, которые не являются простыми. Будем делать это с помощью списка sieve, в котором элемент с индексом i будет представлять число i. По умолчанию заполним всё решето единицами, а если узнаем, что i не является простым, то заменим единицу на ноль. Тогда по окончанию работы функции у нас останется список-решето, в котором единицы будут указывать, какие числа оказались простыми, то есть непросеенными.\n",
    "\n",
    "Сама суть алгоритма решета Эратосфена заключается в следующем: мы перебираем числовой ряд и для каждого числа i отсеиваем числа 2i, 3i, 4i, и так далее. Эти числа точно не являются простыми, ведь они делятся на какое-то натуральное число и ещё на i. Само число i может быть простым, поэтому его мы не отсеиваем. Если при переборе мы натыкаемся на уже отсеенное число, его мы не рассматриваем и идём дальше."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 240,
   "id": "cdf8b043",
   "metadata": {},
   "outputs": [],
   "source": [
    "def eratosthenes(n):\n",
    "    sieve = [1 for i in range(n + 1)]  # <-- заполняем решето единицами\n",
    "    sieve[0] = 0\n",
    "    sieve[1] = 0  # <-- числа 0 и 1 сразу отсеиваем, они не считаются за простые\n",
    "    \n",
    "    for i in range(2, n+1):  # <-- перебираем все числа от 2 до n включительно\n",
    "        print(f\"i = {i}; sieve: {sieve}\")\n",
    "        if sieve[i]:  # <-- имеется в виду: if sieve[i] != 0\n",
    "            for j in range(2*i, n+1, i):  # <-- отсеиваем умноженное\n",
    "                sieve[j] = 0\n",
    "    \n",
    "    return sieve"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2af505ef",
   "metadata": {},
   "source": [
    "Протестируем: попробуем найти простые числа от 2 до 20. Наш алгоритм выводит каждую итерацию большого цикла, чтобы мы могли посмотреть, как работает отсеивание."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 241,
   "id": "29dc2284",
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "i = 2; sieve: [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n",
      "i = 3; sieve: [0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n",
      "i = 4; sieve: [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]\n",
      "i = 5; sieve: [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]\n",
      "i = 6; sieve: [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]\n",
      "i = 7; sieve: [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]\n",
      "i = 8; sieve: [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]\n",
      "i = 9; sieve: [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]\n",
      "i = 10; sieve: [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]\n",
      "i = 11; sieve: [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]\n",
      "i = 12; sieve: [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]\n",
      "i = 13; sieve: [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]\n",
      "i = 14; sieve: [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]\n",
      "i = 15; sieve: [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]\n",
      "i = 16; sieve: [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]\n",
      "i = 17; sieve: [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]\n",
      "i = 18; sieve: [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]\n",
      "i = 19; sieve: [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]\n",
      "i = 20; sieve: [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]\n",
      "[0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]\n"
     ]
    }
   ],
   "source": [
    "sieve = eratosthenes(20)\n",
    "print(sieve)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "24b68d75",
   "metadata": {},
   "source": [
    "Если внимательно посмотреть, можно увидеть, как на итерации i=3 отсеиваются все чётные числа (кроме двойки), на итерации i=4 отсеиваются числа, кратные 3, и так далее. (Обратите внимание: список начинается с индекса 0.)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "97d1b249",
   "metadata": {},
   "source": [
    "«Вынем» все найденные простые числа из получившегося решета:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 245,
   "id": "937e0e7a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[2, 3, 5, 7, 11, 13, 17, 19]\n"
     ]
    }
   ],
   "source": [
    "def simple_eratos(sieve):\n",
    "    return [i for i in range(len(sieve)) if sieve[i]]  # <-- добавляем в список индексы всех элементов решета, где не ноль\n",
    "\n",
    "print(simple_eratos(sieve))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "738c0c81",
   "metadata": {},
   "source": [
    "Наш алгоритм решета Эратосфена тоже можно оптимизировать. Во-первых, уже известным нам способом: заканчивать перебор досрочно на корне из n. Во-вторых, когда мы при отсеивании смотрим на числа 2i, 3i, 4i, …, мы совершаем некоторую лишнюю работу. Если во внешнем цикле мы дошли до числа i, значит, числа 2, 3, … i-2, i-1 и их произведения уже были рассмотрены в предыдущих итерациях. Минимальное число, которое ещё не было отсеено — само число i. Поэтому можно начинать внутренний цикл с отсеиванием не с 2i, а с квадрата i."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 243,
   "id": "78b7b6b2",
   "metadata": {},
   "outputs": [],
   "source": [
    "def eratosthenes(n):\n",
    "    sieve = [1 for i in range(n + 1)]\n",
    "    sieve[0] = 0\n",
    "    sieve[1] = 0\n",
    "    i = 2  # <-- при замене цикла с for на while нужно обозначить стартовое значение\n",
    "    while i**2 <= n+1:  # <-- заменили for на while и теперь заканчиваем на корне из n+1\n",
    "        print(f\"i = {i}; sieve: {sieve}\")\n",
    "        if sieve[i]:\n",
    "            for j in range(i**2, n+1, i):  # <-- теперь начинаем отсеивание с i**2\n",
    "                sieve[j] = 0\n",
    "        i += 1  # <-- при замене цикла с for на while нужно увеличивать итератор руками\n",
    "    return sieve"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 246,
   "id": "bfa2e5b0",
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "i = 2; sieve: [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n",
      "i = 3; sieve: [0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n",
      "i = 4; sieve: [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]\n",
      "[0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]\n"
     ]
    }
   ],
   "source": [
    "sieve = eratosthenes(20)\n",
    "print(sieve)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 247,
   "id": "97cab1c6",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[2, 3, 5, 7, 11, 13, 17, 19]\n"
     ]
    }
   ],
   "source": [
    "print(simple_eratos(sieve))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "778d926a",
   "metadata": {},
   "source": [
    "Как похорошел алгоритм при оптимизации!.."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "75f8a055",
   "metadata": {},
   "source": [
    "### Задача 4.1: Решето Эратосфена для разложения на множители"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ac68b1b3",
   "metadata": {},
   "source": [
    "Задача разложения на простые множители напрямую связана с задачей поиска простых чисел в заданном диапазоне. Поэтому алгоритм решета Эратосфена можно приспособить под разложение числа на множители."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "90b30c79",
   "metadata": {},
   "source": [
    "Вот тут что-то я не так записал…"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 251,
   "id": "4926a2d4",
   "metadata": {},
   "outputs": [],
   "source": [
    "def check(sieve, n):\n",
    "    k = []\n",
    "    while n != 1:\n",
    "        k.append(sieve[n])\n",
    "        n //= sieve[n]\n",
    "    return sieve[n]\n",
    "\n",
    "def eratos_factorization(n):\n",
    "    sieve = [1 for i in range(n + 1)]\n",
    "    sieve[0] = 1\n",
    "    sieve[1] = 1\n",
    "    i = 2\n",
    "    while i**2 <= n+1: # better than —— for i in range(2, int())\n",
    "        #print(e)\n",
    "        if sieve[i] == i:\n",
    "            for j in range(i**2, n+1, i): # better than —— range(2*i, n+1, i)\n",
    "                if sieve[j] == j:\n",
    "                    sieve[j] = i\n",
    "        i += 1\n",
    "    return sieve"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "00501d23",
   "metadata": {},
   "source": [
    "# Классы для решения задач с точками и векторами"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "54cc37f1",
   "metadata": {},
   "source": [
    "Задача: фрёкен Бок, Малыш и Карлсон находятся в разных точках на координатной плоскости. Фрёкен Бок смотрит на Малыша по прямой. Необходимо определить, в каком ухе жужжит у фрёкен Бок от пропеллера Карлсона, то есть где находится Карлсон относительно её взгляда — слева, справа или ровно по прямой."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b80bf2f1",
   "metadata": {},
   "source": [
    "Используем для решения этой задачи классы. Напишем класс *Point*, который будет обозначать точку."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 255,
   "id": "9d71efed",
   "metadata": {},
   "outputs": [],
   "source": [
    "class Point:\n",
    "    \n",
    "    def __init__(self, x, y):\n",
    "        self.x = x\n",
    "        self.y = y\n",
    "    \n",
    "    def dist(self, another: Point):\n",
    "        return math.hypot(self.x - another.x, self.y - another.y)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "97e36a62",
   "metadata": {},
   "source": [
    "В функции *init* прописываются базовые свойства объекта класса. Функция *dist* будет выдавать расстояние между двумя точками."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 256,
   "id": "85b9ed3f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "5.0\n"
     ]
    }
   ],
   "source": [
    "p1 = Point(0, 0)\n",
    "p2 = Point(3, 4)\n",
    "\n",
    "print(p1.dist(p2))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "10d45f1b",
   "metadata": {},
   "source": [
    "Другой класс сделаем для векторов. Добавим в него так называемые [специальные методы](https://pyneng.readthedocs.io/ru/old_chapter_order/book/26_oop_special_methods/index.html), которые можно установить для любого класса. Их можно вызывать не только по названиям, но и особыми простыми сокращениями. Например, функция *mul* представляет собой операцию умножения. Прописав этот метод для класса, мы сможем умножать векторы обычным знаком умножения в Python — астериском. Метод *repr* нужен для строкового отображения объекта класса при вызове функции *print*. Набор специальных методов, встроенных в Python, ограничен. Все они в коде обрамляются двойным подчёркиванием."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 258,
   "id": "17ffbe22",
   "metadata": {},
   "outputs": [],
   "source": [
    "class Vector:\n",
    "    \n",
    "    def __init__(self, a, b):\n",
    "        if isinstance(a, int) and isinstance(b, int):  # <-- если в класс подаются числа, то считаем их координатами вектора\n",
    "            self.x = a\n",
    "            self.y = b\n",
    "        elif isinstance(a, Point) and isinstance(b, Point):  # <-- если в класс подаются точки, то считаем их координатами\n",
    "            self.x = a.x - b.x                               #      начала и конца вектора\n",
    "            self.y = a.y - b.y  # <-- тогда нужно вычислить координаты вектора вычитанием координат начала и конца\n",
    "    \n",
    "    def __repr__(self):\n",
    "        return f\"Vector({self.x}, {self.y})\"  # <-- строковое представление объекта\n",
    "    \n",
    "    def __mul__(self, another):\n",
    "        return self.x * another.x + self.y * another.y  # <-- скалярное произведение (dot product)\n",
    "    \n",
    "    def __mod__(self, another):\n",
    "        return self.x * another.y - self.y * another.x  # <-- векторное произведение (cross product)\n",
    "    \n",
    "    def __add__(self, another):\n",
    "        return Vector(self.x + another.x, self.y + another.y)  # <-- сложение векторов\n",
    "    \n",
    "    def __sub__(self, another):\n",
    "        return Vector(self.x - another.x, self.y - another.y)  # <-- вычитание векторов\n",
    "    \n",
    "    def length(self):\n",
    "        return math.hypot(self.x, self.y)  # <-- длина вектора (не специальный метод)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2a6af5b4",
   "metadata": {},
   "source": [
    "Протестируем класс. Создадим два вектора и применим к ним все четыре базовых операции."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 263,
   "id": "83d7afc8",
   "metadata": {},
   "outputs": [],
   "source": [
    "v1 = Vector(3, 4)  # <-- x = 3, y = 4\n",
    "v2 = Vector(4, -3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 261,
   "id": "81567d86",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0\n",
      "-25\n",
      "Vector(7, 1)\n",
      "Vector(-1, 7)\n"
     ]
    }
   ],
   "source": [
    "print(v1 * v2)\n",
    "print(v1 % v2)\n",
    "print(v1 + v2)\n",
    "print(v1 - v2)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ccfa1fc2",
   "metadata": {},
   "source": [
    "Наши векторы оказались перпендикулярны, поэтому их скалярное произведение равно 0."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7a52c02f",
   "metadata": {},
   "source": [
    "Итак, приступим к решению задачи. Вот так, как показано ниже, можно ввести значения векторов через *input*. С помощью астериска перед *list* мы превращаем элементы списка в набор переменных, который можно передать классу, и создаём переменные-точки для каждого персонажа."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 280,
   "id": "a6d6ac6f",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0 0\n",
      "0 5\n",
      "-2 -3\n"
     ]
    }
   ],
   "source": [
    "froeken = Point(*list(map(int, input().split())))   #  0  0\n",
    "malysh = Point(*list(map(int, input().split())))   #  0  5\n",
    "karlsson = Point(*list(map(int, input().split())))  # -2 -3"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bdc452ca",
   "metadata": {},
   "source": [
    "Отдельная функция будет принимать эти точки и решать задачу. Она найдёт векторное произведение двух векторов, прямых линий от фрёкен до Малыша и до Карлсона. По этому векторному произведению будет понятно, с какой стороны находится Карлсон.\n",
    "\n",
    "(Векторное произведение равно произведению длин векторов на синус угла между ними. Длины всегда положительны, а синус меняет знак в зависимости от того, с какой стороны от вектора a находится b. Так, если синус положительный, то вектор b слева от a, если отрицательный — справа, а если равен нулю — векторы коллинеарны.)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 278,
   "id": "34617eae",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Right\n"
     ]
    }
   ],
   "source": [
    "def solve_karlsson(froeken, malysh, karlsson):\n",
    "    v1 = Vector(froeken, malysh)\n",
    "    v2 = Vector(froeken, karlsson)\n",
    "    s = v1 % v2\n",
    "    \n",
    "    if s == 0:\n",
    "        return \"Both\"\n",
    "    elif s > 0:\n",
    "        return \"Left\"\n",
    "    else:\n",
    "        return \"Right\"\n",
    "\n",
    "print(solve_karlsson(froeken, malysh, karlsson))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "be085ad0",
   "metadata": {},
   "source": [
    "Ура!"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
